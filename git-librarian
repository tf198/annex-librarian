#!/usr/bin/env python2.7

import argparse
import sys
import logging
import os.path
import json

from librarian import Librarian

logger = logging.getLogger(__name__)

def run_sync(l, options):
    return l.sync(options.commit, options.fresh)

def run_search(l, options):
    result = l.search(" ".join(options.terms), options.offset, options.limit)
    for r in result['matches']:
        if options.json:
            sys.stdout.write(json.dumps(r))
            sys.stdout.write("\n")
        else:
            sys.stdout.write("%s\n" % r['key'])

def run_server(l, options):
    from librarian.api import create_api
    from flask import Flask, send_from_directory
    from gevent.wsgi import WSGIServer
    from librarian.watcher import FileWatcher

    api = create_api(l)

    app = Flask(__name__)
    app.register_blueprint(api, url_prefix='/api')

    here = os.path.dirname(os.path.realpath(__file__))
    logger.info("Serving static files from %s", here);

    @app.route('/public/<path:path>')
    @app.route('/public/', defaults={'path': 'index.html'})
    def static_files(path):
        return send_from_directory(os.path.join(here, 'public'), path)

    w = FileWatcher(l.relative_path('.git/refs/heads/git-annex'), l.sync)
    w.start()
    
    sys.stderr.write("Listening on %d\n" % options.port)
    WSGIServer(('', options.port), app).serve_forever()

def run_index(l, options): 
    result = l.run_indexer(options.files, options.keys)
    return "Indexed {indexed} of {total} files".format(**result)

parser = argparse.ArgumentParser(description="Curator for your annexed data")

parser.add_argument('-C', default='.', dest="path", 
        help="Run as if git was started in <PATH>")
parser.add_argument('-l', dest="logging",
        help="Logging string (format: name:level, default: none)")

subparsers = parser.add_subparsers();

sync_cmd = subparsers.add_parser('sync', help="Synchronize library",
        description="Read all new commits and index data")
sync_cmd.add_argument('-c', '--commit', help="From commit")
sync_cmd.add_argument('-f', '--fresh', action="store_true", default=False, 
        help="Clear current database and start from scratch")
sync_cmd.set_defaults(func=run_sync)

search_cmd = subparsers.add_parser('search', help="Search library",
        description="Output a list keys which match the search terms")
search_cmd.add_argument('terms', nargs="+",
        help="Search terms")
search_cmd.add_argument('-o', '--offset', type=int, default=0,
        help="Offset results")
search_cmd.add_argument('-l', '--limit', type=int, default=20,
        help="Limit results")
search_cmd.add_argument('--json', action="store_true",
        help="Output one JSON object per line with key, date and rank properties")
search_cmd.set_defaults(func=run_search)

server_cmd = subparsers.add_parser('server', help="Run api server")
server_cmd.add_argument('-p', '--port', type=int, default=7920,
        help="Port to use")
server_cmd.set_defaults(func=run_server)

index_cmd = subparsers.add_parser('index', help="Index one or more documents",
        description="Run all configured indexers on the files specified")
index_cmd.add_argument('-k', '--keys', help="Items are keys, not files")
index_cmd.add_argument('-i', '--indexer', default="auto", help="Use a specific indexer")
index_cmd.add_argument('files', nargs="*" ,help="Files to index")
index_cmd.set_defaults(func=run_index)

args = parser.parse_args()

if not hasattr(args, 'func'):
    parser.print_help()
    exit(1)

if args.logging:
    log = args.logging.split(':')
    if len(log) == 1: log.append('INFO')

    target = logging.getLogger(log[0])
    target.setLevel(getattr(logging, log[1].upper(), logging.INFO))

    console = logging.StreamHandler(sys.stderr)
    console.setFormatter(logging.Formatter("%(levelname)5s: %(message)s"))
    target.addHandler(console)

logger = logging.getLogger(__name__)
logger.debug("Args: %r", args)

try:
    l = Librarian(args.path)
    result = args.func(l, args)
    if result:
        sys.stdout.write(result)
        sys.stdout.write("\n")
except Exception as e:
    sys.stderr.write("Error: {0}\n".format(e))
    logging.exception(e)
    exit(1)
